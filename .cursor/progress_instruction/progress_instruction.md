项目后端技术栈中使用了 **FastAPI** 。FastAPI是一个现代、高性能的Python Web框架，它基于**异步编程 (Asynchronous Programming)** 构建，通常与ASGI服务器（如Uvicorn或Hypercorn）一起运行。

以下是具体的工作原理：

1.  **异步函数 (`async def`)**：
    * 在FastAPI中，处理HTTP请求的路径操作函数（endpoint functions）通常被定义为异步函数，使用 `async def` 语法。
    * 当您的代码中有一个需要等待I/O操作（如调用外部API、数据库查询、文件读写）的地方时，您会使用 `await` 关键字。

2.  **事件循环 (Event Loop)**：
    * ASGI服务器（如Uvicorn）运行一个事件循环。这个事件循环负责管理和调度多个并发任务。
    * 当一个异步函数执行到 `await some_io_operation()`（例如 `await call_gemini_api()`）时，它并不会阻塞整个worker进程。
    * 相反，它会告诉事件循环：“我现在需要等待这个I/O操作完成，在我等待的时候，你可以去处理其他事情。”然后，这个任务会暂停，并将控制权交还给事件循环。

3.  **并发处理新请求**：
    * 此时，如果有一个新的API请求进来（比如获取工作列表 `request job list`），即使是同一个worker进程，事件循环也可以接收这个新请求并开始处理它。
    * 如果这个新请求的处理也是异步的，并且也涉及到I/O等待，它同样会在等待时将控制权交还给事件循环。

4.  **任务恢复**：
    * 当之前等待的Gemini API响应返回时，事件循环会收到通知。
    * 事件循环随后会唤醒之前暂停的那个任务（即调用Gemini API的那个请求处理函数），从它上次 `await` 的地方继续执行。

**简而言之，对于I/O密集型操作（如等待API响应）：**

* **单个worker进程**在FastAPI（或其他异步框架）中可以**并发处理成百上千个请求**。
* “等待”并不意味着worker完全停止工作。它只是暂停了当前这个需要等待的任务，转而去处理其他可以立即进行或也处于等待状态的任务。
* 这种机制被称为**协作式多任务 (Cooperative Multitasking)**。各个任务通过 `await` 主动让出控制权。

**重要注意事项：**

* **异步代码**：为了实现这种并发，所有可能引起阻塞的I/O操作（网络请求、数据库操作等）都必须使用支持 `async/await` 的库，并且在调用时使用 `await`。例如，使用 `httpx` 而不是 `requests` 进行异步HTTP调用，使用 `asyncpg` 或异步模式的SQLAlchemy进行异步数据库操作
* **CPU密集型任务**：如果某个任务是CPU密集型的（例如，复杂的计算或图像处理算法，而不是等待外部响应），那么它仍然会阻塞事件循环，阻止其他任务在该worker中执行。对于这类任务，需要采用其他策略，如将其卸载到单独的线程池或进程池，或者使用Celery这样的任务队列。不过，在您描述的场景中，等待Gemini API响应是典型的I/O密集型操作。
* **多worker进程**：当单个worker进程的CPU达到瓶颈，或者为了更好的容错性和利用多核CPU，您仍然可以运行多个Uvicorn worker进程。每个worker进程都会有自己的事件循环，独立地并发处理请求。

因此，即使只有一个worker进程，FastAPI的异步特性也能确保在等待Gemini API响应的同时，能够立即响应并处理新的、不相关的请求，如获取工作列表。